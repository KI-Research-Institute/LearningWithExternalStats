#' Compute maximal standardized mean difference
#'
#' @description Compute maximal standardized mean difference (SMD) between two sets where the first set is represented
#' by a vector of statistics and the second set by a possibly weighted sample of transformed data.
#'
#' @details the data is assumed to have been generated by table 1 like transformation function
#'
#' @param mu statistics
#' @param Z data
#' @param w (optional) weights
#'
#' @return Returns the maximal SMD
#'
#' @export
computeMaxSMD <- function(mu, Z, w=NULL) {
  # TODO - make this more efficient
  colSets <- extractInteractionColumnSets(names(mu))
  p <- length(colSets)
  n <- nrow(Z)
  d <- vector(mode = 'numeric', length = p)
  for (i in 1:p) {
    vars <- colSets[[i]]
    if (length(vars) == 2)
      d[i] <- continuousVarSMD(mu[vars], Z[,vars], w)
    else {
      if (length(vars) == 1)
        d[i] <- binaryVarSMD(mu[vars], Z[,vars], w)
      else {
        if (length(vars) == 0)
          ParallelLogger::logWarn(glue('Column set {i}, size 0 not fit for SMD'))  # TODO check specific cases
        else
          ParallelLogger::logWarn(glue('Column set {i}, size {length(vars)} not fit for SMD v1={vars[1]}'))
      }
    }
  }
  return(max(d, na.rm = T))
}



# TODO the following function relies on assumptions
binaryVarSMD <- function(m0, Z, w=NULL) {
  if (is.null(w))
    m1 <- mean(Z)
  else
    m1 <- t(Z) %*% w
  v0 <- m0*(1-m0)
  v1 <- m0*(1-m0)
  return(abs(m1-m0)/sqrt(v0+v1))
}


# TODO the following function relies on assumptions
continuousVarSMD <- function(mu0, Z, w=NULL) {
  if (is.null(w)) {
    mu1 <- colMeans(Z)
  }
  else {
    mu1 <- t(Z) %*% w
  }
  v0 <- mu0[2] - mu0[1]**2
  v1 <- mu1[2] - mu1[1]**2
  return(abs(mu1[1]-mu0[1])/sqrt(v0+v1))
}




extractInteractionColumnSets <- function(featureNames) {
  tokens <- sapply(featureNames, function(x) strsplit(x, '_Table1T'))  # TODO this relies on transformation format
  mainVars <- unique(sapply(tokens, function(x) x[1]))
  covariates <- mainVars[mainVars!='Y']
  p <- length(covariates)
  # TODO - make this more efficient
  colSets <- list(c('Y'))
  for (i in 1:p) {
    currentVar <- covariates[i]
    idxs <- sapply(featureNames, function(x) (startsWith(x, paste(currentVar, '_', sep='') )) )
    varFeatures <- featureNames[idxs]
    for (y in 0:1) {
      idxs <- sapply(varFeatures, function(x) (endsWith(x, paste('y', as.character(y), sep='') )) )
      if (any(idxs))
        colSets[[length(colSets)+1]] <- varFeatures[idxs]
    }
  }
  return(colSets)
}
