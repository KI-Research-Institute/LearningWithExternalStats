#' Compute maximal standardized mean difference
#'
#' @description Compute maximal standardized mean difference (SMD) between two sets where the first set is represented
#' by a vector of statistics and the second set by a possibly weighted sample of transformed data.
#'
#' @details the data is assumed to have been generated by table 1 like transformation function
#'
#' @param mu statistics
#' @param Z data
#' @param w (optional) weights
#'
#' @return Returns the maximal SMD
#'
#' @export
computeMaxSMD <- function(mu, Z, w=NULL) {
  # TODO - make this more efficient
  colSets <- extractInteractionColumnSets(names(mu))
  p <- length(colSets)
  n <- nrow(Z)
  d <- vector(mode = 'numeric', length = p)
  for (i in 1:p) {
    vars <- colSets[[i]]
    if (length(vars) == 2)
      d[i] <- continuousVarSMD(mu[vars], Z[,vars], w)
    else {
      if (length(vars) == 1) {
        Zi <- Z[,vars]
        vals <- unique(Zi)
        if (length(vals)==2)
          d[i] <- binaryVarSMD(mu[vars], Zi, w)
        else {  # Assuming equal variances
          meanZi <- t(Zi) %*% w
          meanZi2 <- t(Zi**2) %*% w
          if (meanZi2 > meanZi)
            d[i] <- abs(meanZi-mu[vars])/sqrt(2*(meanZi2-meanZi))
          else {
            if (meanZi2==meanZi) {
              ParallelLogger::logInfo(glue('{vars} has {length(vals)} values'))
              d[i] <- abs(meanZi-mu[vars])/sqrt(0.001) # Trimming variance at 0.001
            } else {
              ParallelLogger::logWarn(glue('Bad variance {meanZi2-meanZi}'))
            }
          }
        }
      }
      else {
        if (length(vars) == 0)
          ParallelLogger::logWarn(glue('Column set {i}, size 0 not fit for SMD'))  # TODO check specific cases
        else
          ParallelLogger::logWarn(glue('Column set {i}, size {length(vars)} not fit for SMD v1={vars[1]}'))
      }
    }
  }
  return(max(d, na.rm = T))
}


# TODO the following function relies on assumptions
binaryVarSMD <- function(m0, Z, w=NULL) {

  minZ <- min(Z)
  maxZ <- max(Z)
  if (m0<minZ || m0>maxZ) {
    ParallelLogger::logWarn(glue('Stat {m0} is out of range {minZ}-{maxZ}'))
    return(Inf)
  }
  if (is.null(w))
    m1 <- mean(Z)
  else
    m1 <- t(Z) %*% w
  diffZ <- maxZ-minZ
  p1 <- (m1-minZ)/diffZ
  p0 <- (m0-minZ)/diffZ

  v0 <- p0*(1-p0)*diffZ
  v1 <- p1*(1-p1)*diffZ

  if (v1 <= 0 || v0 <= 0)
    ParallelLogger::logInfo(glue('m0={m0} m1={m1} diffZ={diffZ}'))

  return(abs(m1-m0)/sqrt(v0+v1))

}


# TODO the following function relies on assumptions
continuousVarSMD <- function(mu0, Z, w=NULL) {
  if (is.null(w)) {
    mu1 <- colMeans(Z)
  }
  else {
    mu1 <- t(Z) %*% w
  }
  v0 <- mu0[2] - mu0[1]**2
  v1 <- mu1[2] - mu1[1]**2
  return(abs(mu1[1]-mu0[1])/sqrt(v0+v1))
}




extractInteractionColumnSets <- function(featureNames) {
  tokens <- sapply(featureNames, function(x) strsplit(x, '_Table1T'))  # TODO this relies on transformation format
  mainVars <- unique(sapply(tokens, function(x) x[1]))
  covariates <- mainVars[mainVars!='Y']
  p <- length(covariates)
  # TODO - make this more efficient
  colSets <- list(c('Y'))
  for (i in 1:p) {
    currentVar <- covariates[i]
    idxs <- sapply(featureNames, function(x) (startsWith(x, paste(currentVar, '_', sep='') )) )
    varFeatures <- featureNames[idxs]
    for (y in 0:1) {
      idxs <- sapply(varFeatures, function(x) (endsWith(x, paste('y', as.character(y), sep='') )) )
      if (any(idxs))
        colSets[[length(colSets)+1]] <- varFeatures[idxs]
    }
  }
  return(colSets)
}
